#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"
#include "vecmat.h"
#include "msg.h"
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#define debug 1
#define trace if (debug) write

// Set up the header for all of the methods.
void getRay(Perspective p, float screenCoord[2], Ray *ray);

char buffer[256];
const unsigned int width = 512;
const unsigned int height = 512;
unsigned char ImageArray[512 * 512 *3];

enum material {
    reflective = 0,
		red = 1,
    green = 2,
    blue = 3
};

typedef struct {
	float vector[3];
	float position[3];
	int numReflections; //10
} Ray;

typedef struct {
	const	float cameraPos[3]; //{0.0,0.0,0.0}
	const float distanceToScreen; //2
	const unsigned int widthWorld; //2
	const unsigned int widthPixels; //512
} Perspective;

Perspective *perspective = NULL;

typedef struct {
	float t;
	Ray ray;
	int objectCode;
	Sphere * sph;
	Triangle * tri;
} RayHit;

typedef struct {
  float pos[3];
  int radius;
  int mat;
} Sphere;

typedef struct {
	float pos[3];
	
} Triangle;

void getRay(Perspective p, float screenCoord[2], Ray *ray) { 
	ray.vector = normalize((screenCoord, p.distanceToScreen) - p.cameraPos);
	ray.position = (screenCoord, p.distanceToScreen);
}

int RaySphereIntersect(Ray *ray, Sphere *sph){
  float e[3] = ray.vector;
  float d[3] = ray.position;
  float c[3] = sph.pos;
  float r = sph.radius;
  float eminc = 0;
  vec3f_sub_new(eminc,e,c);
  float discriminant = (vec3f_dot(e,c)*vec3f_dot(e,c))-vec3f_dot(d,d) * vec3f_dot(eminc,eminc)-(r*r);
  float t = 0;
  float tpos = 0;
  float tneg = 0;

  if(discriminant>0){//which one do I take?
    t = (-vec3f_dot(e,c))/ vec3f_dot(d,d);
  }else if(discriminant==0){
    tpos = (-vec3f_dot(e,c) + sqrt( discriminant ) )/ vec3f_dot(d,d);
    tneg = (-vec3f_dot(e,c) - sqrt( discriminant ) )/ vec3f_dot(d,d);

    if(tpos<tneg){
      t = tpos;
    }else{
      t = tneg;
    }
  }else{
    t = 0;
  }
  return t;
}

int RayTriangleIntersect(Ray *ray, Triangle *tri) {
	
}

int main(int argc, char* argv[]){
  if(argc<2 || argc>3){
    sprintf(buffer, "Invalid number of arguments: Expected 1, got %d\n", argc-1);
  	write(2, buffer, strlen(buffer));
    return -1;
  }
  char* filename;

  if(strcmp( argv[2], "reference" )) {
    filename = "reference.png";
  } else if(strcmp( argv[2], "custom")) {
    filename = "custom.png";
  } else {
    fprintf (stderr, "Invalid output arument: Expected either \"reference\" or \"custom\"; got %s\n", argv[2]);
    return -1;
  }

	Sphere testSphere = malloc(sizeof(Sphere));
	testSphere.pos[0] = 1;//x
	testSphere.pos[1] = 0;//y
	testSphere.pos[2] = 1;//z
	testSphere.radius = 1;
	testSphere.mat = 1;

	for (int x=0; x<height; x++) {
		for (int y=0; y<width; y++) {
			getRay();
		
			

			// Calculate and set the color of the pixel.
      ImageArray[512*x+3*y]=255;//blue
			ImageArray[512*x+3*y-1]=255;//green
			ImageArray[512*x+3*y-2]=255;//red
		}
	}
  sprintf(buffer, "stbi_write_png(%s, %d, %d, %d, ImageArray, %lu)\n",filename, width, height, 3, width*3);
  trace(1, buffer, strlen(buffer));

  stbi_write_png(filename, width, height, 3, ImageArray, width*3);

  return 1;
}
